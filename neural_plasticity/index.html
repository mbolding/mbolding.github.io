<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Plasticity Sim</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #111111;
            --secondary-text: #666666;
            --accent-color: #ff3300;
            --card-bg: #f9f9f9;
            --border-color: #e5e5e5;
            --input-bg: #eeeeee;
            --node-input: #0070f3;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #111111;
                --text-color: #ffffff;
                --secondary-text: #999999;
                --card-bg: #1a1a1a;
                --border-color: #333333;
                --input-bg: #222222;
                --node-input: #3291ff;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 60px 40px;
            width: 100%;
            flex-grow: 1;
        }

        header {
            margin-bottom: 60px;
            border-bottom: 4px solid var(--text-color);
            padding-bottom: 20px;
        }

        h1 {
            font-size: 48px;
            font-weight: 800;
            margin: 0 0 16px 0;
            letter-spacing: -2px;
            text-transform: uppercase;
            line-height: 1;
        }

        .subtitle {
            font-size: 18px;
            font-weight: 400;
            color: var(--secondary-text);
            max-width: 800px;
        }

        .layout-grid {
            display: grid;
            grid-template-columns: 1fr 340px;
            gap: 40px;
        }

        /* Simulation Canvas Area */
        .canvas-wrapper {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            position: relative;
            aspect-ratio: 4/3;
            width: 100%;
            overflow: hidden;
            border-radius: 4px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .overlay-label {
            position: absolute;
            top: 20px;
            left: 20px;
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--secondary-text);
            pointer-events: none;
            mix-blend-mode: difference;
        }

        /* Controls Sidebar */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 32px;
        }

        .control-group {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 32px;
        }

        .control-group:last-child {
            border-bottom: none;
        }

        h3 {
            font-size: 12px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 16px;
            color: var(--text-color);
        }

        .btn-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        button {
            background-color: var(--input-bg);
            color: var(--text-color);
            border: none;
            padding: 12px 16px;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            border-radius: 4px;
        }

        button:hover {
            background-color: var(--border-color);
        }

        button.active {
            background-color: var(--accent-color);
            color: #ffffff;
        }

        button.primary {
            background-color: var(--text-color);
            color: var(--bg-color);
        }

        button.primary:hover {
            opacity: 0.9;
        }

        /* Sliders */
        .slider-container {
            margin-bottom: 20px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
            font-weight: 500;
        }

        .slider-val {
            font-family: monospace;
            color: var(--accent-color);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: var(--border-color);
            outline: none;
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--text-color);
            cursor: pointer;
            border-radius: 50%;
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Metrics */
        .metrics {
            margin-top: 20px;
        }

        .metric-item {
            margin-bottom: 20px;
        }

        .metric-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--secondary-text);
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
        }

        .stat-value {
            color: var(--text-color);
            font-weight: 700;
        }

        .sparkline {
            width: 100%;
            height: 40px;
            background: var(--card-bg);
            border-bottom: 1px solid var(--border-color);
            border-radius: 2px;
        }

        .legend-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }

        @media (max-width: 900px) {
            .layout-grid {
                grid-template-columns: 1fr;
            }

            .container {
                padding: 40px 20px;
            }

            h1 {
                font-size: 36px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Neural Plasticity NEEDS WORK</h1>
            <p class="subtitle">Simulation of synaptic plasticity in a recurrent network. Explore Hebbian dynamics and
                response to high-frequency inputs.</p>
        </header>

        <div class="layout-grid">
            <!-- Main Visualization -->
            <div class="visualization">
                <div class="canvas-wrapper">
                    <span class="overlay-label">Network Activity</span>
                    <canvas id="simCanvas"></canvas>
                </div>
            </div>

            <!-- Controls Sidebar -->
            <div class="controls">

                <!-- Playback -->
                <div class="control-group">
                    <h3>Control</h3>
                    <div class="btn-row">
                        <button id="playPauseBtn" class="primary">Pause</button>
                        <button id="resetBtn">Reset</button>
                    </div>
                </div>

                <!-- Learning Rules -->
                <div class="control-group">
                    <h3>Plasticity Rule</h3>
                    <div class="btn-row">
                        <button id="hebbianBtn" class="active">Hebbian</button>
                        <button id="antiHebbianBtn">Anti-Hebbian</button>
                    </div>
                    <div style="margin-top: 12px; font-size: 12px; color: var(--secondary-text); line-height: 1.4;">
                        <span id="ruleDesc"><strong>Hebbian:</strong> "Fire together, wire together." Connections
                            strengthen when neurons activate simultaneously.</span>
                    </div>
                </div>

                <!-- Parameters -->
                <div class="control-group">
                    <h3>Parameters</h3>

                    <div class="slider-container">
                        <div class="slider-header">
                            <span>Learning Rate</span>
                            <span class="slider-val" id="lrVal">0.05</span>
                        </div>
                        <input type="range" id="lrSlider" min="0" max="0.2" step="0.01" value="0.05">
                    </div>

                    <div class="slider-container">
                        <div class="slider-header">
                            <span>Weight Decay</span>
                            <span class="slider-val" id="decayVal">0.01</span>
                        </div>
                        <input type="range" id="decaySlider" min="0" max="0.05" step="0.001" value="0.01">
                    </div>

                    <div class="slider-container">
                        <div class="slider-header">
                            <span>Noise Level</span>
                            <span class="slider-val" id="noiseVal">0.02</span>
                        </div>
                        <input type="range" id="noiseSlider" min="0" max="0.1" step="0.01" value="0.02">
                    </div>
                </div>

                <!-- Inputs -->
                <div class="control-group">
                    <h3>External Input <span class="legend-indicator"
                            style="background-color: var(--node-input); margin-left:8px;"></span></h3>

                    <div class="slider-container">
                        <div class="slider-header">
                            <span>Input Frequency</span>
                            <span class="slider-val" id="freqVal">0.0</span>
                        </div>
                        <input type="range" id="freqSlider" min="0" max="0.5" step="0.01" value="0.0">
                    </div>
                    <div style="font-size: 12px; color: var(--secondary-text);">
                        Increases firing rate of designated input nodes (Blue).
                    </div>
                </div>

                <!-- Metrics -->
                <div class="control-group">
                    <h3>Metrics</h3>
                    <div class="metrics">
                        <div class="metric-item">
                            <div class="metric-label">
                                <span>Avg Weight</span>
                                <span class="stat-value" id="avgWeightStat">0.50</span>
                            </div>
                            <canvas id="weightSpark" class="sparkline"></canvas>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">
                                <span>Global Activity</span>
                                <span class="stat-value" id="activityStat">0%</span>
                            </div>
                            <canvas id="activitySpark" class="sparkline"></canvas>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <script>
        /**
         * Configuration & State within a closure to avoid global pollution
         */
        const App = (() => {
            // -- Constants --
            const NUM_NEURONS = 42;
            const GRID_COLS = 6; // approximate

            // -- Classes --

            class Neuron {
                constructor(id, x, y) {
                    this.id = id;
                    this.x = x; // range 0.0 - 1.0
                    this.y = y; // range 0.0 - 1.0

                    this.v = 0.0;     // Membrane potential
                    this.spiked = false;
                    this.refractory = 0;

                    this.isInputNode = false;
                }

                update(noiseLevel, inputFreq) {
                    // 1. Decay
                    this.v *= 0.9;

                    // 2. Noise (Spontaneous activity)
                    if (Math.random() < noiseLevel) {
                        this.v += 0.4;
                    }

                    // 3. External High-Freq Input (if applicable)
                    if (this.isInputNode && Math.random() < inputFreq) {
                        this.v += 0.8;
                    }

                    // 4. Refractory & Spiking Logic
                    this.spiked = false;
                    if (this.refractory > 0) {
                        this.refractory--;
                        this.v = 0; // clamped
                    } else if (this.v >= 1.0) {
                        this.spiked = true;
                        this.v = 0;
                        this.refractory = 4; // Refractory duration
                    }
                }

                zap(amount) {
                    this.v += amount;
                }
            }

            class Synapse {
                constructor(pre, post) {
                    this.pre = pre;
                    this.post = post;
                    this.w = 0.5; // Initial weight
                }

                transmit() {
                    if (this.pre.spiked) {
                        // Impact post-synaptic neuron
                        // Weight scales the inputs
                        this.post.zap(this.w * 0.5);
                    }
                }

                learn(lr, decay, isHebbian) {
                    // Simple Co-activity rule
                    // If Pre fired AND Post fired "now" (simultaneous window)
                    const coActive = (this.pre.spiked && this.post.spiked);

                    if (coActive) {
                        if (isHebbian) {
                            // LTP
                            this.w += lr * (1.0 - this.w);
                        } else {
                            // LTD (Anti-Hebbian)
                            this.w -= lr * (this.w);
                        }
                    }

                    // Simple Homeostatic Decay applied every step (slowly forgets)
                    // Decays towards 0.5 to keep things dynamic, or 0.0? 
                    // Let's decay specifically towards 0 (depression) or center
                    // Standard usage usually decays towards 0, but we want a baseline.
                    // Implementation: Decay towards 0.5
                    this.w -= decay * (this.w - 0.5);

                    // Hard Clamp
                    this.w = Math.max(0.01, Math.min(1.0, this.w));
                }
            }

            // -- App State --
            const state = {
                running: true,
                params: {
                    lr: 0.05,
                    decay: 0.01,
                    noise: 0.02,
                    inputFreq: 0.0,
                    isHebbian: true
                },
                network: {
                    neurons: [],
                    synapses: []
                },
                history: {
                    weight: new Array(50).fill(0.5),
                    activity: new Array(50).fill(0)
                }
            };

            // -- Initialization --
            function initNetwork() {
                state.network.neurons = [];
                state.network.synapses = [];

                const rows = Math.ceil(NUM_NEURONS / GRID_COLS);

                // Create Neurons
                for (let i = 0; i < NUM_NEURONS; i++) {
                    const r = Math.floor(i / GRID_COLS);
                    const c = i % GRID_COLS;

                    // Grid positions with jitter
                    const jx = (Math.random() - 0.5) * 0.4;
                    const jy = (Math.random() - 0.5) * 0.4;

                    // Normalize to approximately 0-1 space (with padding handled in draw)
                    const x = (c + 0.5 + jx) / GRID_COLS;
                    const y = (r + 0.5 + jy) / rows;

                    const n = new Neuron(i, x, y);
                    state.network.neurons.push(n);
                }

                // Pick Input Nodes (3 random)
                let inputsPicked = 0;
                while (inputsPicked < 3) {
                    const idx = Math.floor(Math.random() * NUM_NEURONS);
                    if (!state.network.neurons[idx].isInputNode) {
                        state.network.neurons[idx].isInputNode = true;
                        inputsPicked++;
                    }
                }

                // Create Synapses (Distance based)
                state.network.neurons.forEach(pre => {
                    state.network.neurons.forEach(post => {
                        if (pre === post) return;

                        const dx = pre.x - post.x;
                        const dy = pre.y - post.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        // Connectivity rule: prefer close neighbors
                        if (dist < 0.35 && Math.random() < 0.4) {
                            state.network.synapses.push(new Synapse(pre, post));
                        }
                    });
                });

                // Reset History
                state.history.weight.fill(0.5);
                state.history.activity.fill(0);
            }

            // -- Simulation Step --
            function step() {
                if (!state.running) return;

                const { neurons, synapses } = state.network;
                const p = state.params;

                // 1. Update Neurons (Integrate & Fire)
                neurons.forEach(n => n.update(p.noise, p.inputFreq));

                // 2. Transmit Spikes
                synapses.forEach(s => s.transmit());

                // 3. Plasticity
                synapses.forEach(s => s.learn(p.lr, p.decay, p.isHebbian));

                // 4. Stats
                const totalW = synapses.reduce((acc, s) => acc + s.w, 0);
                const avgW = synapses.length ? totalW / synapses.length : 0;
                const active = neurons.filter(n => n.spiked).length;

                state.history.weight.push(avgW);
                state.history.weight.shift();

                const activityPct = active / neurons.length;
                state.history.activity.push(activityPct);
                state.history.activity.shift();

                // 5. DOM Updates (Throttled ideally, but lightweight here)
                dom.avgWeight.textContent = avgW.toFixed(2);
                dom.activity.textContent = Math.round(activityPct * 100) + '%';
            }

            // -- Visualization --
            const canvas = document.getElementById('simCanvas');
            const ctx = canvas.getContext('2d');

            // Sparklines
            const ctxW = document.getElementById('weightSpark').getContext('2d');
            const ctxA = document.getElementById('activitySpark').getContext('2d');

            let width, height;

            function resize() {
                const p = canvas.parentElement;
                width = p.clientWidth;
                height = p.clientHeight;

                const dpr = window.devicePixelRatio || 1;

                // Main Canvas
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                ctx.scale(dpr, dpr);

                // Sparks
                resizeSpark(document.getElementById('weightSpark'), ctxW);
                resizeSpark(document.getElementById('activitySpark'), ctxA);
            }

            function resizeSpark(el, c) {
                const r = el.getBoundingClientRect();
                el.width = r.width * window.devicePixelRatio;
                el.height = r.height * window.devicePixelRatio;
            }

            // Colors (computed style handling)
            function getColors() {
                const style = getComputedStyle(document.body);
                const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                return {
                    bg: style.getPropertyValue('--bg-color').trim(),
                    node: style.getPropertyValue('--border-color').trim(), // inactive node
                    nodeInput: style.getPropertyValue('--node-input').trim(),
                    accent: style.getPropertyValue('--accent-color').trim(),
                    text: style.getPropertyValue('--text-color').trim()
                };
            }

            function draw() {
                const cols = getColors();

                // Clear
                ctx.clearRect(0, 0, width, height);

                // Draw Synapses
                // We draw them behind nodes
                state.network.synapses.forEach(s => {
                    if (s.w < 0.05) return; // Skip very weak links

                    const x1 = s.pre.x * width * 0.8 + width * 0.1;
                    const y1 = s.pre.y * height * 0.8 + height * 0.1;
                    const x2 = s.post.x * width * 0.8 + width * 0.1;
                    const y2 = s.post.y * height * 0.8 + height * 0.1;

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);

                    // Style
                    ctx.lineWidth = 1 + (s.w * 2);

                    // If active pathway (pre & post fired), highlight
                    if (s.pre.spiked && s.post.spiked) {
                        ctx.strokeStyle = cols.accent;
                        ctx.globalAlpha = 1.0;
                    } else {
                        // Base color depends on theme
                        ctx.strokeStyle = cols.text;
                        ctx.globalAlpha = 0.05 + (s.w * 0.15);
                    }
                    ctx.stroke();
                });
                ctx.globalAlpha = 1.0;


                // Draw Nodes
                state.network.neurons.forEach(n => {
                    const cx = n.x * width * 0.8 + width * 0.1;
                    const cy = n.y * height * 0.8 + height * 0.1;

                    ctx.beginPath();

                    // Radius logic
                    const r = n.isInputNode ? 6 : 4;
                    const rSpike = n.spiked ? r + 4 : r;

                    ctx.arc(cx, cy, rSpike, 0, Math.PI * 2);

                    if (n.spiked) {
                        ctx.fillStyle = cols.accent;
                    } else if (n.isInputNode) {
                        ctx.fillStyle = cols.nodeInput;
                    } else {
                        // Inactive, but slight fill if potential is high
                        ctx.fillStyle = cols.node;
                    }

                    ctx.fill();

                    // Input Ring
                    if (n.isInputNode) {
                        ctx.strokeStyle = cols.nodeInput;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(cx, cy, r + 4, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                });

                // Sparklines
                drawSpark(ctxW, state.history.weight, 0, 1, cols.accent);
                drawSpark(ctxA, state.history.activity, 0, 1, cols.accent);
            }

            function drawSpark(c, data, min, max, col) {
                const w = c.canvas.width;
                const h = c.canvas.height;
                c.clearRect(0, 0, w, h);

                c.beginPath();
                c.strokeStyle = col;
                c.lineWidth = 2 * window.devicePixelRatio;

                const dx = w / (data.length - 1);

                data.forEach((val, i) => {
                    const norm = (val - min) / (max - min);
                    // Flip Y
                    const y = h - (norm * h);
                    if (i === 0) c.moveTo(0, y);
                    else c.lineTo(i * dx, y);
                });
                c.stroke();
            }

            function loop() {
                step();
                draw();
                requestAnimationFrame(loop);
            }

            // -- DOM Wiring --
            const dom = {
                playPause: document.getElementById('playPauseBtn'),
                reset: document.getElementById('resetBtn'),
                hebbian: document.getElementById('hebbianBtn'),
                antiHebbian: document.getElementById('antiHebbianBtn'),
                ruleDesc: document.getElementById('ruleDesc'),

                lrVal: document.getElementById('lrVal'),
                lrSlider: document.getElementById('lrSlider'),
                decayVal: document.getElementById('decayVal'),
                decaySlider: document.getElementById('decaySlider'),
                noiseVal: document.getElementById('noiseVal'),
                noiseSlider: document.getElementById('noiseSlider'),
                freqVal: document.getElementById('freqVal'),
                freqSlider: document.getElementById('freqSlider'),

                avgWeight: document.getElementById('avgWeightStat'),
                activity: document.getElementById('activityStat')
            };

            function bindEvents() {
                dom.playPause.onclick = () => {
                    state.running = !state.running;
                    dom.playPause.textContent = state.running ? "Pause" : "Play";
                };

                dom.reset.onclick = () => {
                    initNetwork();
                    // Reset visual history too
                    state.history.weight.fill(0.5);
                    state.history.activity.fill(0);
                };

                // Rules
                dom.hebbian.onclick = () => {
                    state.params.isHebbian = true;
                    dom.hebbian.classList.add('active');
                    dom.antiHebbian.classList.remove('active');
                    dom.ruleDesc.innerHTML = '<strong>Hebbian:</strong> "Fire together, wire together." Connections strengthen when neurons activate simultaneously.';
                };
                dom.antiHebbian.onclick = () => {
                    state.params.isHebbian = false;
                    dom.antiHebbian.classList.add('active');
                    dom.hebbian.classList.remove('active');
                    dom.ruleDesc.innerHTML = '<strong>Anti-Hebbian:</strong> "Fire together, wire apart." Connections weaken when neurons activate simultaneously. Useful for de-correlation.';
                };

                // Sliders
                dom.lrSlider.oninput = (e) => {
                    state.params.lr = parseFloat(e.target.value);
                    dom.lrVal.textContent = state.params.lr;
                };
                dom.decaySlider.oninput = (e) => {
                    state.params.decay = parseFloat(e.target.value);
                    dom.decayVal.textContent = state.params.decay;
                };
                dom.noiseSlider.oninput = (e) => {
                    state.params.noise = parseFloat(e.target.value);
                    dom.noiseVal.textContent = state.params.noise;
                };
                dom.freqSlider.oninput = (e) => {
                    state.params.inputFreq = parseFloat(e.target.value);
                    dom.freqVal.textContent = state.params.inputFreq;
                };

                // Canvas Interaction (Click to zap)
                canvas.addEventListener('mousedown', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left) / rect.width;
                    const y = (e.clientY - rect.top) / rect.height;

                    // Transform to Sim Coords which are 0-1 but drawn in 0.1-0.9 box
                    // The drawing logic is: cx = n.x * 0.8 + 0.1
                    // So n.x = (cx - 0.1) / 0.8
                    const sx = (x - 0.1) / 0.8;
                    const sy = (y - 0.1) / 0.8;

                    // Find neighbors
                    state.network.neurons.forEach(n => {
                        const dx = n.x - sx;
                        const dy = n.y - sy;
                        if (dx * dx + dy * dy < 0.005) {
                            n.zap(1.0); // manual fire
                        }
                    });
                });
            }

            // -- Start --
            initNetwork();
            bindEvents();
            window.addEventListener('resize', resize);
            resize();
            requestAnimationFrame(loop);

        })();
    </script>
</body>

</html>