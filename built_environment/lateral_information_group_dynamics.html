<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lateral Flow Dynamics</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Instrument+Serif:ital@0;1&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-primary: #f8f5f0;
            --bg-secondary: #ebe6df;
            --bg-tertiary: #ddd6cc;
            --text-primary: #1a1816;
            --text-secondary: #5c564e;
            --accent: #c44b2b;
            --accent-glow: rgba(196, 75, 43, 0.4);
            --group-1: #2d5a4a;
            --group-2: #8b4d6b;
            --group-3: #c49a3b;
            --group-4: #3d5a8c;
            --group-5: #7c5c3c;
            --info-pulse: #c44b2b;
            --edge-color: rgba(90, 85, 78, 0.25);
            --edge-active: rgba(196, 75, 43, 0.8);
        }

        .dark {
            --bg-primary: #0f0e0d;
            --bg-secondary: #1a1917;
            --bg-tertiary: #252320;
            --text-primary: #e8e4de;
            --text-secondary: #9a948a;
            --accent: #e86f4c;
            --accent-glow: rgba(232, 111, 76, 0.5);
            --edge-color: rgba(150, 145, 135, 0.15);
            --edge-active: rgba(232, 111, 76, 0.9);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            transition: background 0.4s, color 0.4s;
        }

        .app-container {
            display: grid;
            grid-template-columns: 320px 1fr;
            min-height: 100vh;
        }

        @media (max-width: 900px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
        }

        .control-panel {
            background: var(--bg-secondary);
            padding: 24px;
            border-right: 1px solid var(--bg-tertiary);
            overflow-y: auto;
            max-height: 100vh;
        }

        @media (max-width: 900px) {
            .control-panel {
                max-height: none;
                border-right: none;
                border-bottom: 1px solid var(--bg-tertiary);
            }
        }

        .logo {
            font-family: 'Instrument Serif', serif;
            font-size: 28px;
            font-style: italic;
            margin-bottom: 8px;
            color: var(--accent);
        }

        .subtitle {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-secondary);
            margin-bottom: 32px;
        }

        .section {
            margin-bottom: 28px;
        }

        .section-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-secondary);
            margin-bottom: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--bg-tertiary);
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .control-value {
            color: var(--accent);
            font-weight: 700;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-tertiary);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px var(--accent-glow);
            transition: transform 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .btn {
            width: 100%;
            padding: 14px 20px;
            font-family: 'Space Mono', monospace;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.25s;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            box-shadow: 0 4px 20px var(--accent-glow);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: var(--text-secondary);
            color: var(--bg-primary);
        }

        .simulation-area {
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .viz-header {
            padding: 20px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--bg-tertiary);
            flex-wrap: wrap;
            gap: 12px;
        }

        .metrics {
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
        }

        .metric {
            text-align: center;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent);
            line-height: 1;
        }

        .metric-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-secondary);
        }

        .status-dot.active {
            background: var(--accent);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 0 0 var(--accent-glow);
            }

            50% {
                box-shadow: 0 0 0 8px transparent;
            }
        }

        #network-canvas {
            flex: 1;
            width: 100%;
            min-height: 500px;
            background:
                radial-gradient(circle at 20% 30%, var(--bg-secondary) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, var(--bg-secondary) 0%, transparent 50%),
                var(--bg-primary);
        }

        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 8px;
            font-size: 11px;
            border: 1px solid var(--bg-tertiary);
        }

        .legend-title {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 8px;
            font-size: 11px;
            border: 1px solid var(--bg-tertiary);
            max-width: 220px;
        }

        .info-panel h4 {
            font-family: 'Instrument Serif', serif;
            font-size: 16px;
            font-weight: normal;
            margin-bottom: 8px;
        }

        .info-panel p {
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .node {
            cursor: pointer;
            transition: filter 0.2s;
        }

        .node:hover {
            filter: brightness(1.2);
        }

        .node-informed {
            animation: informPulse 0.6s ease-out;
        }

        @keyframes informPulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.5);
            }

            100% {
                transform: scale(1);
            }
        }

        .edge {
            stroke: var(--edge-color);
            stroke-width: 1.5;
            transition: stroke 0.3s, stroke-width 0.3s;
        }

        .edge.active {
            stroke: var(--edge-active);
            stroke-width: 2.5;
        }

        .tooltip {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--bg-tertiary);
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
        }

        .tooltip.visible {
            opacity: 1;
        }
    </style>
</head>

<body>
    <div class="app-container">
        <aside class="control-panel">
            <div class="logo">Lateral Flow</div>
            <div class="subtitle">Information Dynamics Simulator</div>

            <div class="section">
                <div class="section-title">Network Structure</div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Number of Groups</span>
                        <span class="control-value" id="groupCountValue">4</span>
                    </div>
                    <input type="range" id="groupCount" min="2" max="6" value="4">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Nodes per Group</span>
                        <span class="control-value" id="nodesPerGroupValue">8</span>
                    </div>
                    <input type="range" id="nodesPerGroup" min="4" max="15" value="8">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Intra-group Density</span>
                        <span class="control-value" id="intraDensityValue">70%</span>
                    </div>
                    <input type="range" id="intraDensity" min="20" max="100" value="70">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Group Dynamics</div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Cross-group Bridges</span>
                        <span class="control-value" id="bridgesValue">15%</span>
                    </div>
                    <input type="range" id="bridges" min="0" max="50" value="15">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Silo Strength</span>
                        <span class="control-value" id="siloValue">40%</span>
                    </div>
                    <input type="range" id="silo" min="0" max="100" value="40">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Trust Level</span>
                        <span class="control-value" id="trustValue">60%</span>
                    </div>
                    <input type="range" id="trust" min="10" max="100" value="60">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Simulation</div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Propagation Speed</span>
                        <span class="control-value" id="speedValue">Medium</span>
                    </div>
                    <input type="range" id="speed" min="1" max="5" value="3">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Information Decay</span>
                        <span class="control-value" id="decayValue">20%</span>
                    </div>
                    <input type="range" id="decay" min="0" max="80" value="20">
                </div>
            </div>

            <button class="btn btn-primary" id="startBtn">Start Propagation</button>
            <button class="btn btn-secondary" id="resetBtn">Reset Network</button>
            <button class="btn btn-secondary" id="regenerateBtn">Regenerate</button>
        </aside>

        <main class="simulation-area">
            <header class="viz-header">
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="reachMetric">0%</div>
                        <div class="metric-label">Network Reach</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="timeMetric">0</div>
                        <div class="metric-label">Time Steps</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="efficiencyMetric">--</div>
                        <div class="metric-label">Flow Efficiency</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="bottleneckMetric">0</div>
                        <div class="metric-label">Bottlenecks</div>
                    </div>
                </div>
                <div class="status-indicator">
                    <div class="status-dot" id="statusDot"></div>
                    <span id="statusText">Ready</span>
                </div>
            </header>

            <svg id="network-canvas"></svg>

            <div class="legend">
                <div class="legend-title">Groups</div>
                <div id="legendItems"></div>
            </div>

            <div class="info-panel">
                <h4>How it works</h4>
                <p>Click any node to start information propagation. Watch how group dynamics affect lateral flow across
                    the network.</p>
            </div>

            <div class="tooltip" id="tooltip"></div>
        </main>
    </div>

    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            document.documentElement.classList.toggle('dark', event.matches);
        });

        // Configuration
        const groupColors = ['#2d5a4a', '#8b4d6b', '#c49a3b', '#3d5a8c', '#7c5c3c', '#5a3d6b'];
        const groupNames = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta'];

        let config = {
            groupCount: 4,
            nodesPerGroup: 8,
            intraDensity: 0.7,
            bridges: 0.15,
            silo: 0.4,
            trust: 0.6,
            speed: 3,
            decay: 0.2
        };

        let nodes = [];
        let edges = [];
        let simulation;
        let isRunning = false;
        let animationFrame;
        let timeSteps = 0;

        const svg = d3.select('#network-canvas');
        let width, height;
        let edgeGroup, nodeGroup;

        function initSVG() {
            const rect = svg.node().getBoundingClientRect();
            width = rect.width;
            height = rect.height;

            svg.selectAll('*').remove();

            // Add defs for glow effect
            const defs = svg.append('defs');
            const filter = defs.append('filter')
                .attr('id', 'glow')
                .attr('x', '-50%')
                .attr('y', '-50%')
                .attr('width', '200%')
                .attr('height', '200%');
            filter.append('feGaussianBlur')
                .attr('stdDeviation', '3')
                .attr('result', 'coloredBlur');
            const feMerge = filter.append('feMerge');
            feMerge.append('feMergeNode').attr('in', 'coloredBlur');
            feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

            edgeGroup = svg.append('g').attr('class', 'edges');
            nodeGroup = svg.append('g').attr('class', 'nodes');
        }

        function generateNetwork() {
            nodes = [];
            edges = [];

            // Create nodes for each group
            for (let g = 0; g < config.groupCount; g++) {
                const angle = (2 * Math.PI * g) / config.groupCount;
                const groupCenterX = width / 2 + Math.cos(angle) * Math.min(width, height) * 0.25;
                const groupCenterY = height / 2 + Math.sin(angle) * Math.min(width, height) * 0.25;

                for (let n = 0; n < config.nodesPerGroup; n++) {
                    nodes.push({
                        id: `${g}-${n}`,
                        group: g,
                        groupName: groupNames[g],
                        x: groupCenterX + (Math.random() - 0.5) * 80,
                        y: groupCenterY + (Math.random() - 0.5) * 80,
                        informed: false,
                        informedTime: null,
                        connections: 0
                    });
                }
            }

            // Create intra-group edges
            for (let g = 0; g < config.groupCount; g++) {
                const groupNodes = nodes.filter(n => n.group === g);
                for (let i = 0; i < groupNodes.length; i++) {
                    for (let j = i + 1; j < groupNodes.length; j++) {
                        if (Math.random() < config.intraDensity) {
                            edges.push({
                                source: groupNodes[i],
                                target: groupNodes[j],
                                type: 'intra',
                                active: false
                            });
                            groupNodes[i].connections++;
                            groupNodes[j].connections++;
                        }
                    }
                }
            }

            // Create cross-group bridges
            for (let g1 = 0; g1 < config.groupCount; g1++) {
                for (let g2 = g1 + 1; g2 < config.groupCount; g2++) {
                    const group1Nodes = nodes.filter(n => n.group === g1);
                    const group2Nodes = nodes.filter(n => n.group === g2);

                    const bridgeCount = Math.floor(Math.min(group1Nodes.length, group2Nodes.length) * config.bridges);

                    for (let b = 0; b < bridgeCount; b++) {
                        const n1 = group1Nodes[Math.floor(Math.random() * group1Nodes.length)];
                        const n2 = group2Nodes[Math.floor(Math.random() * group2Nodes.length)];

                        if (!edges.some(e =>
                            (e.source === n1 && e.target === n2) ||
                            (e.source === n2 && e.target === n1)
                        )) {
                            edges.push({
                                source: n1,
                                target: n2,
                                type: 'bridge',
                                active: false
                            });
                            n1.connections++;
                            n2.connections++;
                        }
                    }
                }
            }

            updateLegend();
            renderNetwork();
            updateMetrics();
        }

        function updateLegend() {
            const legendItems = document.getElementById('legendItems');
            legendItems.innerHTML = '';

            for (let g = 0; g < config.groupCount; g++) {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-dot" style="background: ${groupColors[g]}"></div>
                    <span>${groupNames[g]}</span>
                `;
                legendItems.appendChild(item);
            }
        }

        function renderNetwork() {
            initSVG();

            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(edges).id(d => d.id).distance(60).strength(0.3))
                .force('charge', d3.forceManyBody().strength(-120))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(25))
                .force('x', d3.forceX().x(d => {
                    const angle = (2 * Math.PI * d.group) / config.groupCount;
                    return width / 2 + Math.cos(angle) * Math.min(width, height) * 0.22;
                }).strength(0.15))
                .force('y', d3.forceY().y(d => {
                    const angle = (2 * Math.PI * d.group) / config.groupCount;
                    return height / 2 + Math.sin(angle) * Math.min(width, height) * 0.22;
                }).strength(0.15));

            const edgeElements = edgeGroup.selectAll('line')
                .data(edges)
                .enter()
                .append('line')
                .attr('class', 'edge')
                .style('stroke-dasharray', d => d.type === 'bridge' ? '4,4' : 'none');

            const nodeElements = nodeGroup.selectAll('circle')
                .data(nodes)
                .enter()
                .append('circle')
                .attr('class', 'node')
                .attr('r', d => 8 + d.connections * 0.8)
                .attr('fill', d => groupColors[d.group])
                .on('click', (event, d) => startPropagation(d))
                .on('mouseenter', showTooltip)
                .on('mouseleave', hideTooltip)
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded));

            simulation.on('tick', () => {
                edgeElements
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                nodeElements
                    .attr('cx', d => Math.max(15, Math.min(width - 15, d.x)))
                    .attr('cy', d => Math.max(15, Math.min(height - 15, d.y)));
            });
        }

        function dragStarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }

        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        function dragEnded(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }

        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <strong>${d.groupName} Node</strong><br>
                Connections: ${d.connections}<br>
                Status: ${d.informed ? 'Informed' : 'Uninformed'}
            `;
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        function startPropagation(sourceNode) {
            if (isRunning) return;

            resetNodeStates();
            sourceNode.informed = true;
            sourceNode.informedTime = 0;
            timeSteps = 0;
            isRunning = true;

            document.getElementById('statusDot').classList.add('active');
            document.getElementById('statusText').textContent = 'Propagating';
            document.getElementById('startBtn').textContent = 'Running...';

            updateNodeVisuals();
            propagate();
        }

        function propagate() {
            const speedDelay = [1500, 1000, 600, 300, 150][config.speed - 1];

            const propagateStep = () => {
                timeSteps++;
                let newlyInformed = [];

                const informedNodes = nodes.filter(n => n.informed);

                for (const node of informedNodes) {
                    const connectedEdges = edges.filter(e =>
                        e.source === node || e.target === node
                    );

                    for (const edge of connectedEdges) {
                        const neighbor = edge.source === node ? edge.target : edge.source;

                        if (!neighbor.informed) {
                            let transmitProb = config.trust;

                            // Apply silo effect for cross-group edges
                            if (edge.type === 'bridge') {
                                transmitProb *= (1 - config.silo);
                            }

                            // Apply decay based on time
                            transmitProb *= Math.pow(1 - config.decay, timeSteps - node.informedTime);

                            if (Math.random() < transmitProb) {
                                neighbor.informed = true;
                                neighbor.informedTime = timeSteps;
                                newlyInformed.push(neighbor);
                                edge.active = true;
                            }
                        }
                    }
                }

                updateNodeVisuals();
                updateEdgeVisuals();
                updateMetrics();

                if (newlyInformed.length > 0 && nodes.some(n => !n.informed)) {
                    animationFrame = setTimeout(propagateStep, speedDelay);
                } else {
                    stopPropagation();
                }
            };

            animationFrame = setTimeout(propagateStep, speedDelay);
        }

        function stopPropagation() {
            isRunning = false;
            document.getElementById('statusDot').classList.remove('active');
            document.getElementById('statusText').textContent = 'Complete';
            document.getElementById('startBtn').textContent = 'Start Propagation';

            // Calculate efficiency
            const reached = nodes.filter(n => n.informed).length;
            const efficiency = reached > 1 ? Math.round((reached / nodes.length) / Math.max(1, timeSteps) * 100) : 0;
            document.getElementById('efficiencyMetric').textContent = efficiency + '%';

            // Count bottlenecks (uninformed nodes with informed neighbors)
            let bottlenecks = 0;
            nodes.forEach(n => {
                if (!n.informed) {
                    const hasInformedNeighbor = edges.some(e =>
                        (e.source === n && e.target.informed) ||
                        (e.target === n && e.source.informed)
                    );
                    if (hasInformedNeighbor) bottlenecks++;
                }
            });
            document.getElementById('bottleneckMetric').textContent = bottlenecks;
        }

        function updateNodeVisuals() {
            nodeGroup.selectAll('circle')
                .attr('fill', d => d.informed ?
                    getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() :
                    groupColors[d.group])
                .attr('filter', d => d.informed ? 'url(#glow)' : 'none');
        }

        function updateEdgeVisuals() {
            edgeGroup.selectAll('line')
                .classed('active', d => d.active);
        }

        function updateMetrics() {
            const informed = nodes.filter(n => n.informed).length;
            const reach = Math.round((informed / nodes.length) * 100);
            document.getElementById('reachMetric').textContent = reach + '%';
            document.getElementById('timeMetric').textContent = timeSteps;
        }

        function resetNodeStates() {
            if (animationFrame) clearTimeout(animationFrame);

            nodes.forEach(n => {
                n.informed = false;
                n.informedTime = null;
            });

            edges.forEach(e => {
                e.active = false;
            });

            timeSteps = 0;
            isRunning = false;

            document.getElementById('statusDot').classList.remove('active');
            document.getElementById('statusText').textContent = 'Ready';
            document.getElementById('startBtn').textContent = 'Start Propagation';
            document.getElementById('efficiencyMetric').textContent = '--';
            document.getElementById('bottleneckMetric').textContent = '0';

            updateNodeVisuals();
            updateEdgeVisuals();
            updateMetrics();
        }

        // Control bindings
        function bindControls() {
            const controls = [
                { id: 'groupCount', key: 'groupCount', display: v => v },
                { id: 'nodesPerGroup', key: 'nodesPerGroup', display: v => v },
                { id: 'intraDensity', key: 'intraDensity', display: v => v + '%', transform: v => v / 100 },
                { id: 'bridges', key: 'bridges', display: v => v + '%', transform: v => v / 100 },
                { id: 'silo', key: 'silo', display: v => v + '%', transform: v => v / 100 },
                { id: 'trust', key: 'trust', display: v => v + '%', transform: v => v / 100 },
                { id: 'speed', key: 'speed', display: v => ['Slowest', 'Slow', 'Medium', 'Fast', 'Fastest'][v - 1] },
                { id: 'decay', key: 'decay', display: v => v + '%', transform: v => v / 100 }
            ];

            controls.forEach(ctrl => {
                const input = document.getElementById(ctrl.id);
                const valueDisplay = document.getElementById(ctrl.id + 'Value');

                input.addEventListener('input', () => {
                    const rawValue = parseInt(input.value);
                    valueDisplay.textContent = ctrl.display(rawValue);
                    config[ctrl.key] = ctrl.transform ? ctrl.transform(rawValue) : rawValue;
                });
            });

            document.getElementById('startBtn').addEventListener('click', () => {
                if (!isRunning) {
                    const randomNode = nodes[Math.floor(Math.random() * nodes.length)];
                    startPropagation(randomNode);
                }
            });

            document.getElementById('resetBtn').addEventListener('click', resetNodeStates);
            document.getElementById('regenerateBtn').addEventListener('click', generateNetwork);
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            const rect = svg.node().getBoundingClientRect();
            width = rect.width;
            height = rect.height;

            if (simulation) {
                simulation.force('center', d3.forceCenter(width / 2, height / 2));
                simulation.alpha(0.3).restart();
            }
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initSVG();
            bindControls();

            // Small delay to ensure proper sizing
            setTimeout(generateNetwork, 100);
        });
    </script>
</body>

</html>