<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lebesgue Integration</title>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="style.css">
    <style>
:root {
            
            
            
            --riemann: #3182ce;
            --lebesgue: #d69e2e;
            --highlight: #ffeeaa;
        }
        header,
        .viz-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 2rem 0;
        }
        canvas {
            background-color: #fff;
            border: 1px solid #ccc;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            cursor: crosshair;
        }
        .controls {
            margin-top: 1rem;
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        button {
            padding: 8px 16px;
            background: #eee;
            border: 1px solid #ccc;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        button:hover {
            background: #ddd;
        }
        button.active {
            background: var(--fg);
            color: var(--bg);
            border-color: var(--fg);
        }
        .mode-toggle {
            display: flex;
            border: 1px solid #ccc;
            border-radius: 4px;
            overflow: hidden;
        }
        .mode-toggle button {
            border: none;
            border-right: 1px solid #ccc;
            border-radius: 0;
        }
        .mode-toggle button:last-child {
            border-right: none;
        }
        .slider-container {
            width: 100%;
            max-width: 400px;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 1rem;
            font-family: 'Gill Sans', sans-serif;
            font-size: 0.9rem;
        }
        input[type="range"] {
            flex-grow: 1;
        }
        .info-box {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.03);
            border-radius: 4px;
            font-family: 'Gill Sans', sans-serif;
            width: 100%;
            max-width: 600px;
        }
        @media (max-width: 1200px) {
        }
    </style>
</head>

<body>

    <header>
        <a href="index.html"
            style="text-decoration: none; color: #888; font-size: 0.9rem; font-family: 'Gill Sans', sans-serif;">&larr;
            Back to Index</a>
        <h1>Lebesgue Integration</h1>
        <span class="subtitle">Chapter 12: Comparing Riemann and Lebesgue</span>
    </header>

    <main>
        <p>
            <strong>Riemann Integration</strong> partitions the <em>domain</em> ($x$-axis) into small intervals and sums
            the area of rectangles.
            <strong>Lebesgue Integration</strong> partitions the <em>range</em> ($y$-axis) into slices and sums the
            measure of the sets mapped to those values.
        </p>

        <p>
            <span class="sidenote">
                <strong>Henri Lebesgue:</strong> "I have to pay a certain sum... Riemann counts the coins one by one...
                I stack coins of same value and count each stack."
            </span>
            <strong>Instructions:</strong> Switch between modes. Use the slider to increase partitions. Hover over the
            graph to highlight specific slices.
        </p>

        <div class="viz-container">
            <div class="controls">
                <div class="mode-toggle">
                    <button onclick="setMode('riemann')" id="btn-riemann" class="active">Riemann (Domain)</button>
                    <button onclick="setMode('lebesgue')" id="btn-lebesgue">Lebesgue (Range)</button>
                </div>
            </div>

            <div class="slider-container">
                <span>Partitions ($N$):</span>
                <input type="range" id="param-n" min="2" max="50" value="10" oninput="updateN(this.value)">
                <span id="val-n">10</span>
            </div>

            <canvas id="canvas" width="600" height="400"></canvas>

            <div class="info-box" id="info">
                Hover over the plot to see details.
            </div>
        </div>
    
            <div class="chapter-nav">
            <a href="algebra.html" class="nav-link">
            <span style="font-size:1.2rem;">&larr;</span>
            <div>
            <span>Previous</span>
            <strong>Chapter 11: Algebra</strong>
            </div>
            </a>
            <a href="fourier.html" class="nav-link" style="text-align: right; flex-direction: row-reverse;">
            <span style="font-size:1.2rem;">&rarr;</span>
            <div>
            <span>Next</span>
            <strong>Chapter 13: Fourier Analysis</strong>
            </div>
            </a>
            </div>
    </main>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const info = document.getElementById('info');

        // Config
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;
        const MARGIN = 40;
        const PLOT_W = WIDTH - 2 * MARGIN;
        const PLOT_H = HEIGHT - 2 * MARGIN;

        let mode = 'riemann'; // or 'lebesgue'
        let N = 10;
        let hoverIdx = -1;
        let mathJaxPromise = Promise.resolve();

        function setInfo(html) {
            info.innerHTML = html;
            if (window.MathJax && window.MathJax.typesetPromise) {
                mathJaxPromise = mathJaxPromise.then(() => {
                    return window.MathJax.typesetPromise([info]);
                }).catch(err => console.error(err));
            }
        }

        // Function f(x)
        // Domain [0, 10]
        // Range approx [0, 5]
        function f(x) {
            return 2 + Math.sin(x) + 0.5 * Math.sin(2.5 * x) + 0.2 * x;
        }

        const X_MIN = 0;
        const X_MAX = 10;
        const Y_MIN = 0;
        const Y_MAX = 5;

        function toPixel(x, y) {
            const px = MARGIN + ((x - X_MIN) / (X_MAX - X_MIN)) * PLOT_W;
            const py = HEIGHT - MARGIN - ((y - Y_MIN) / (Y_MAX - Y_MIN)) * PLOT_H;
            return { x: px, y: py };
        }

        function fromPixel(px, py) {
            const x = X_MIN + ((px - MARGIN) / PLOT_W) * (X_MAX - X_MIN);
            const y = Y_MIN + ((HEIGHT - MARGIN - py) / PLOT_H) * (Y_MAX - Y_MIN);
            return { x, y };
        }

        function setMode(m) {
            mode = m;
            document.querySelectorAll('.mode-toggle button').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + m).classList.add('active');
            draw();
        }

        function updateN(val) {
            N = parseInt(val);
            document.getElementById('val-n').textContent = N;
            draw();
        }

        function drawCurve() {
            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            let first = true;
            for (let px = 0; px <= PLOT_W; px += 2) {
                const x = X_MIN + (px / PLOT_W) * (X_MAX - X_MIN);
                const y = f(x);
                const p = toPixel(x, y);
                if (first) { ctx.moveTo(p.x, p.y); first = false; }
                else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
        }

        function drawAxes() {
            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 1;

            // X Axis
            const origin = toPixel(X_MIN, 0);
            const xEnd = toPixel(X_MAX, 0);
            ctx.beginPath(); ctx.moveTo(origin.x, origin.y); ctx.lineTo(xEnd.x, xEnd.y); ctx.stroke();

            // Y Axis
            const yEnd = toPixel(X_MIN, Y_MAX);
            ctx.beginPath(); ctx.moveTo(origin.x, origin.y); ctx.lineTo(yEnd.x, yEnd.y); ctx.stroke();
        }

        function drawRiemann() {
            const dx = (X_MAX - X_MIN) / N;
            const widthPx = (PLOT_W / N); // close enough approximation

            let totalArea = 0;

            for (let i = 0; i < N; i++) {
                const xLeft = X_MIN + i * dx;
                // Left Riemann Sum
                const h = f(xLeft);
                totalArea += h * dx;

                const p1 = toPixel(xLeft, 0);
                const p2 = toPixel(xLeft, h);

                // Draw Rect
                ctx.beginPath();
                ctx.fillStyle = (i === hoverIdx) ? 'rgba(49, 130, 206, 0.6)' : 'rgba(49, 130, 206, 0.2)'; // var(--riemann)
                ctx.strokeStyle = '#2b6cb0';

                const pxWidth = (PLOT_W / (X_MAX - X_MIN)) * dx;

                // Canvas rect is x, y, w, h. y is top-left.
                // p2.y is the top. height is (p1.y - p2.y)
                const rectH = p1.y - p2.y;

                ctx.rect(p2.x, p2.y, pxWidth, rectH);
                ctx.fill();
                ctx.stroke();
            }

            if (hoverIdx !== -1) {
                const h = f(X_MIN + hoverIdx * dx);
                setInfo(`<strong>Riemann:</strong> Partition ${hoverIdx + 1}/${N}<br>Height $f(x^*) \\approx ${h.toFixed(2)}$<br>Area contribution: ${(h * dx).toFixed(2)}`);
            } else {
                setInfo(`<strong>Total Area (Riemann Sum):</strong> ${totalArea.toFixed(3)}`);
            }
        }

        function drawLebesgue() {
            // Partition Range [0, ~4.5]
            const yMaxActual = 4.5;
            const dy = yMaxActual / N;

            let totalMeasure = 0;
            let totalIntegral = 0;

            // We need to inverse map: find x intervals where y_i <= f(x) < y_{i+1}
            // Simple sampling approach since f(x) is complex?
            // Resolution of sampling
            const SAMPLES = 400;
            const dx = (X_MAX - X_MIN) / SAMPLES;

            // Draw horizontal bands
            for (let j = 0; j < N; j++) {
                const yLow = j * dy;
                const yHigh = (j + 1) * dy;

                const pLow = toPixel(X_MIN, yLow);
                const pHigh = toPixel(X_MIN, yHigh);
                const layerH = pLow.y - pHigh.y;

                // Visual band
                ctx.beginPath();
                ctx.fillStyle = (j === hoverIdx) ? 'rgba(214, 158, 46, 0.6)' : 'rgba(214, 158, 46, 0.25)';
                ctx.strokeStyle = (j === hoverIdx) ? '#d69e2e' : 'rgba(214, 158, 46, 0.5)';

                ctx.rect(MARGIN, pHigh.y, PLOT_W, layerH);
                ctx.fill();
                ctx.stroke();

                // Identify sets on X axis
                let measure = 0;
                // To display measure on X axis, we scan X
                if (j === hoverIdx) {
                    ctx.fillStyle = '#d69e2e';
                    for (let k = 0; k < SAMPLES; k++) {
                        const x = X_MIN + k * dx;
                        const val = f(x);
                        if (val >= yLow && val < yHigh) { // In set E_j
                            measure += dx;
                            const pX = toPixel(x, 0);
                            const pW = (PLOT_W / SAMPLES) + 1; // overlap slightly to fill gaps
                            ctx.fillRect(pX.x, pX.y + 2, pW, 6);
                        }
                    }
                    totalIntegral += yLow * measure; // Just current slice
                    setInfo(`<strong>Lebesgue:</strong> Slice $y \\in [${yLow.toFixed(2)}, ${yHigh.toFixed(2)})$<br>Measure $\\mu(E_j) \\approx ${measure.toFixed(2)}$<br>Contribution $y_j \\cdot \\mu(E_j) \\approx ${(yLow * measure).toFixed(2)}$`);
                } else {
                    // Just calc total
                    // Doing full calc for all non-hovered is expensive every frame?
                    // Let's do it simply.
                    // The visual is key.
                }
            }

            // Calc total integral once if not hovering?
            if (hoverIdx === -1) {
                // Sample
                for (let k = 0; k < SAMPLES; k++) {
                    const x = X_MIN + k * dx;
                    const val = f(x);
                    // Find bin
                    const bin = Math.floor(val / dy);
                    if (bin >= 0 && bin < N) {
                        totalIntegral += (bin * dy) * dx; // y_j * dx contribution
                    }
                }
                setInfo(`<strong>Total Area (Lebesgue Sum):</strong> ${totalIntegral.toFixed(3)}`);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            drawAxes();

            if (mode === 'riemann') drawRiemann();
            else drawLebesgue();

            drawCurve();
        }

        // Interaction
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const m = fromPixel(x, y);

            if (mode === 'riemann') {
                // Determine partition index
                if (m.x >= X_MIN && m.x <= X_MAX) {
                    const dx = (X_MAX - X_MIN) / N;
                    hoverIdx = Math.floor((m.x - X_MIN) / dx);
                    if (hoverIdx >= N) hoverIdx = N - 1;
                } else {
                    hoverIdx = -1;
                }
            } else {
                // Determine slice index
                const yMaxActual = 4.5;
                if (m.y >= 0 && m.y <= yMaxActual) {
                    const dy = yMaxActual / N;
                    hoverIdx = Math.floor(m.y / dy);
                    if (hoverIdx >= N) hoverIdx = N - 1;
                } else {
                    hoverIdx = -1;
                }
            }
            draw();
        });

        canvas.addEventListener('mouseleave', () => {
            hoverIdx = -1;
            draw();
        });

        // Init
        draw();
    </script>
</body>

</html>