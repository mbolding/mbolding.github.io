<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algebra - Group Theory</title>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="style.css">
    <style>
:root {
            
            
            
            --node-bg: #fff;
            --node-border: #333;
            --gen-a: #b13e3e;
            /* Red */
            --gen-b: #3182ce;
            /* Blue */
        }
        .viz-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 2rem 0;
        }
        canvas {
            background-color: #fff;
            border: 1px solid #ccc;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        .controls {
            margin-top: 1rem;
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        button {
            padding: 8px 16px;
            background: #eee;
            border: 1px solid #ccc;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        button:hover {
            background: #ddd;
        }
        button.active {
            background: var(--fg);
            color: var(--bg);
            border-color: var(--fg);
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 0.5rem;
            font-family: 'Gill Sans', sans-serif;
            font-size: 0.9rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .line {
            width: 30px;
            height: 3px;
        }
        @media (max-width: 1200px) {
        }
    </style>
</head>

<body>

        <header>
        <a href="index.html" class="back-link">&larr; Back to Index</a>
        <h1>Group Theory & Cayley Graphs</h1>
        <span class="subtitle">Chapter 11: Algebra</span>
    </header>

    <main>
        <p>
            A <strong>Cayley Graph</strong> visualizes the structure of a group. Nodes represent group elements, and
            colored arrows represent multiplication by generators.
        </p>

        <p>
            <span class="sidenote">
                <strong>Cyclic Groups ($Z_n$):</strong> Generated by one element ($a$).<br>
                <strong>Klein Four ($V_4$):</strong> Non-cyclic, commutative.<br>
                <strong>Symmetric ($S_3$):</strong> Permutations of 3 items. Non-commutative.
            </span>
        </p>
        <p>
            <strong>Instructions:</strong> Select a group to see its structure.
            <span style="color:var(--gen-a)">d</span> arrows multiply by generator $a$.
            <span style="color:var(--gen-b)">d</span> arrows multiply by generator $b$.
        </p>

        <div class="viz-container">
            <div class="controls">
                <button onclick="setGroup('z3')" id="btn-z3">$\mathbb{Z}_3$</button>
                <button onclick="setGroup('z5')" id="btn-z5" class="active">$\mathbb{Z}_5$</button>
                <button onclick="setGroup('v4')" id="btn-v4">$V_4$</button>
                <button onclick="setGroup('s3')" id="btn-s3">$S_3$</button>
            </div>

            <canvas id="canvas" width="600" height="400"></canvas>

            <div class="legend">
                <div class="legend-item">
                    <div class="line" style="background: var(--gen-a)"></div>
                    <span>Generator $a$</span>
                </div>
                <div class="legend-item" id="legend-b">
                    <div class="line" style="background: var(--gen-b)"></div>
                    <span>Generator $b$</span>
                </div>
            </div>
        </div>
    
            <div class="chapter-nav">
            <a href="countability.html" class="nav-link">
            <span style="font-size:1.2rem;">&larr;</span>
            <div>
            <span>Previous</span>
            <strong>Chapter 10: Countability</strong>
            </div>
            </a>
            <a href="lebesgue.html" class="nav-link" style="text-align: right; flex-direction: row-reverse;">
            <span style="font-size:1.2rem;">&rarr;</span>
            <div>
            <span>Next</span>
            <strong>Chapter 12: Lebesgue Integration</strong>
            </div>
            </a>
            </div>
    </main>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Config
        const CX = 300;
        const CY = 200;
        const NODE_R = 18;

        // Data Definitions
        const groups = {
            'z3': {
                name: 'Z3',
                elements: ['e', 'a', 'a²'],
                pos: getCirclePos(3, 100),
                links: [
                    { from: 0, to: 1, type: 'a' },
                    { from: 1, to: 2, type: 'a' },
                    { from: 2, to: 0, type: 'a' }
                ],
                hasB: false
            },
            'z5': {
                name: 'Z5',
                elements: ['e', 'a', 'a²', 'a³', 'a⁴'],
                pos: getCirclePos(5, 120),
                links: [
                    { from: 0, to: 1, type: 'a' },
                    { from: 1, to: 2, type: 'a' },
                    { from: 2, to: 3, type: 'a' },
                    { from: 3, to: 4, type: 'a' },
                    { from: 4, to: 0, type: 'a' }
                ],
                hasB: false
            },
            'v4': {
                name: 'V4',
                // Klein 4: {e, a, b, ab}. a^2=e, b^2=e, ab=ba.
                elements: ['e', 'a', 'b', 'ab'],
                pos: [
                    { x: CX - 80, y: CY - 80 }, // e
                    { x: CX + 80, y: CY - 80 }, // a
                    { x: CX - 80, y: CY + 80 }, // b
                    { x: CX + 80, y: CY + 80 }  // ab
                ],
                links: [
                    // a generator (horizontal)
                    { from: 0, to: 1, type: 'a', db: true }, // double arrow for order 2
                    { from: 2, to: 3, type: 'a', db: true },
                    // b generator (vertical)
                    { from: 0, to: 2, type: 'b', db: true },
                    { from: 1, to: 3, type: 'b', db: true }
                ],
                hasB: true
            },
            's3': {
                name: 'S3',
                // S3 generators a=(12), b=(123).
                // Elements: e, a, b, ab, b^2, ab^2.
                // a^2=e (a is self-inverse). b^3=e.
                // ab = b^2a.
                elements: ['e', 'b', 'b²', 'a', 'ab', 'ab²'],
                // Inner triangle (rotations), Outer triangle (flips)
                pos: [
                    // Inner (b cycles): e, b, b^2
                    { x: CX, y: CY - 60 },           // e (top inner)
                    getHexPoint(CX, CY, 60, 2),  // b (right inner) - actually calc manually
                    getHexPoint(CX, CY, 60, 4),  // b2 (left inner)

                    // Outer (a swaps): a, ab, ab^2
                    { x: CX, y: CY - 140 },          // a (top outer)
                    getHexPoint(CX, CY, 140, 2), // ab (right outer)
                    getHexPoint(CX, CY, 140, 4)  // ab2 (left outer)
                ],
                // Wait, precise coords for S3 prism/hexagon:
                // Let's do a hexagon arrangement? 
                // e -> b -> b2 -> e
                // |    |    |
                // a -> ab -> ab2 -> a (but directions flip?)
                // ab = b^2 a. So b * a = ab^2?
                // Connection: e <-> a. b <-> ab? b^2 <-> ab^2?
                // Let's re-map positions properly.

                // Better layout:
                // Inner circle: e, b, b^2 (radius 60)
                // Outer circle: a, ab, ab^2 (radius 130)
                // Angle offsets: e at -90 (top). b at 30 (bot right). b^2 at 150 (bot left).
                // a at -90. ab at 30. ab^2 at 150.

                pos: (() => {
                    const r1 = 70, r2 = 140;
                    const angs = [-Math.PI / 2, -Math.PI / 2 + 2 * Math.PI / 3, -Math.PI / 2 + 4 * Math.PI / 3];
                    return [
                        { x: CX + r1 * Math.cos(angs[0]), y: CY + r1 * Math.sin(angs[0]) }, // e
                        { x: CX + r1 * Math.cos(angs[1]), y: CY + r1 * Math.sin(angs[1]) }, // b
                        { x: CX + r1 * Math.cos(angs[2]), y: CY + r1 * Math.sin(angs[2]) }, // b^2

                        { x: CX + r2 * Math.cos(angs[0]), y: CY + r2 * Math.sin(angs[0]) }, // a
                        { x: CX + r2 * Math.cos(angs[1]), y: CY + r2 * Math.sin(angs[1]) }, // ab
                        { x: CX + r2 * Math.cos(angs[2]), y: CY + r2 * Math.sin(angs[2]) }  // ab^2 (Wait, check mul table)
                    ];
                    // If a connects e->a, b connects e->b...
                    // ab is a*b or b*a? usually right mul in cayley graph steps?
                    // Let's assume arrows are right multiplication x -> xg.
                    // e -> b (b gen).
                    // e -> a (a gen).
                    // a -> ab (b gen). 
                    // b -> b^2 (b gen).
                })(),

                links: [
                    // b generator (Blue): Cycles e->b->b2->e and a->ab->ab2->a
                    { from: 0, to: 1, type: 'b' }, { from: 1, to: 2, type: 'b' }, { from: 2, to: 0, type: 'b' },
                    // Wait, a*b = ab. ab*b = ab^2. ab^2*b = a.
                    // So outer ring is also a cycle in this layout?
                    // if pos 3 is 'a', 4 is 'ab', 5 is 'ab2'. yes.
                    { from: 3, to: 4, type: 'b' }, { from: 4, to: 5, type: 'b' }, { from: 5, to: 3, type: 'b' },

                    // a generator (Red): Swaps e<->a, b<->ab? No, b*a = ab^2 usually in S3 (non-abelian).
                    // a = (12), b = (123).
                    // ba = (123)(12) = (13). 
                    // ab^2 = (12)(132) = (13). So ba = ab^2.
                    // So b -> ab^2 via a?
                    // Let's check: x -> xa.
                    // e -> a (ok, 0->3)
                    // b -> ba = ab^2 (ok, 1->5)
                    // b^2 -> b^2a = (132)(12) = (23).
                    // ab = (12)(123) = (23). So b^2a = ab. (ok, 2->4)
                    // a -> a^2 = e (ok, 3->0)
                    // ab -> aba = ab b^2a = a e a = a^2 = e? No.
                    // aba = (12)(123)(12) = (13). Not e.
                    // S3 relations: a^2=1, b^3=1, aba=b^{-1}=b^2.
                    // So aba = b^2. ab = b^2 a.
                    // x -> xa.
                    // ab -> aba = b^2. (4->2)
                    // ab^2 -> ab^2a = a(b^2a) = a(ab) = b. (5->1)

                    { from: 0, to: 3, type: 'a', db: true }, // e <-> a
                    { from: 1, to: 5, type: 'a', db: true }, // b <-> ab^2
                    { from: 2, to: 4, type: 'a', db: true }  // b^2 <-> ab
                ],
                hasB: true
            }
        };

        function getCirclePos(n, r) {
            const arr = [];
            for (let i = 0; i < n; i++) {
                const ang = -Math.PI / 2 + (i * 2 * Math.PI / n);
                arr.push({
                    x: CX + r * Math.cos(ang),
                    y: CY + r * Math.sin(ang)
                });
            }
            return arr;
        }

        function getHexPoint(cx, cy, r, idx) {
            // idx 0..5. -90 start
            const ang = -Math.PI / 2 + (idx * Math.PI / 3);
            return { x: cx + r * Math.cos(ang), y: cy + r * Math.sin(ang) };
        }

        // State
        let currentGroup = 'z5';

        function setGroup(id) {
            currentGroup = id;
            document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + id).classList.add('active');

            const g = groups[id];
            document.getElementById('legend-b').style.display = g.hasB ? 'flex' : 'none';

            draw();
        }

        function drawArrow(p1, p2, color, isDouble) {
            // Shorten line to not overlap node circles
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

            const startDist = NODE_R + 5;
            const endDist = dist - (NODE_R + 5);

            if (endDist <= startDist) return; // Too close

            const sx = p1.x + startDist * Math.cos(angle);
            const sy = p1.y + startDist * Math.sin(angle);
            const ex = p1.x + endDist * Math.cos(angle);
            const ey = p1.y + endDist * Math.sin(angle);

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            if (isDouble) {
                // Draw just line, maybe double ticks? Or just line implies bidirectional if simple?
                // Visual convention: Single line without arrow heads for order 2 generator (reciprocal).
                // Or double headed arrow.
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.stroke();
            } else {
                // Draw arrow
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.stroke();

                // Head
                const headLen = 10;
                ctx.beginPath();
                ctx.fillStyle = color;
                ctx.moveTo(ex, ey);
                ctx.lineTo(ex - headLen * Math.cos(angle - Math.PI / 6), ey - headLen * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(ex - headLen * Math.cos(angle + Math.PI / 6), ey - headLen * Math.sin(angle + Math.PI / 6));
                ctx.fill();
            }
        }

        function draw() {
            const g = groups[currentGroup];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            function getCSSVar(name) {
                return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
            }

            // Draw Links
            g.links.forEach(l => {
                const color = (l.type === 'a') ? getCSSVar('--gen-a') : getCSSVar('--gen-b');
                drawArrow(g.pos[l.from], g.pos[l.to], color, l.db);
            });

            // Draw Nodes
            g.pos.forEach((p, i) => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, NODE_R, 0, 2 * Math.PI);
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Text
                ctx.fillStyle = '#111';
                ctx.font = 'bold 14px Consolas';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(g.elements[i], p.x, p.y + 1); // +1 visual adjustment
            });
        }

        // Init
        setGroup('z5');

    </script>
</body>

</html>