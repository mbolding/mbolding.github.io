<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper</title>

    <!-- Swiss Design Typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&family=IBM+Plex+Mono:wght@400;500;700&display=swap"
        rel="stylesheet">

    <style>
        :root {
            /* Swiss Design Color Palette */
            --bg-color: #ffffff;
            --text-color: #111111;
            --secondary-text: #666666;
            --accent-red: #ff3300;
            --accent-green: #10B981;
            --accent-blue: #0055ff;
            --card-bg: #f5f5f5;
            --cell-closed: #e0e0e0;
            --cell-open: #ffffff;
            --cell-hover: #d0d0d0;
            --border-color: #cccccc;

            --cell-size: 32px;
            --grid-gap: 2px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.4;
            padding: 40px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Header */
        header {
            margin-bottom: 40px;
            text-align: center;
            width: 100%;
            border-bottom: 2px solid var(--text-color);
            padding-bottom: 20px;
        }

        h1 {
            font-size: 48px;
            font-weight: 800;
            letter-spacing: -2px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .subtitle {
            font-size: 16px;
            color: var(--secondary-text);
            font-weight: 400;
        }

        /* Controls */
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 600px;
            margin-bottom: 24px;
            background: var(--card-bg);
            padding: 16px;
            font-family: 'IBM Plex Mono', monospace;
        }

        .stat-box {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 700;
            font-size: 20px;
        }

        .face-btn {
            font-size: 24px;
            background: none;
            border: 2px solid transparent;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
            transition: transform 0.1s;
        }

        .face-btn:hover {
            transform: scale(1.1);
        }

        .face-btn:active {
            transform: scale(0.95);
        }

        /* Difficulty Selector */
        .difficulty-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 32px;
        }

        .diff-btn {
            background: var(--card-bg);
            border: 1px solid transparent;
            padding: 8px 16px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .diff-btn:hover {
            background: #e5e5e5;
        }

        .diff-btn.active {
            background: var(--text-color);
            color: var(--bg-color);
        }

        /* Game Grid */
        .game-wrapper {
            background: var(--text-color);
            /* Acts as border via gap */
            padding: 4px;
            user-select: none;
            display: inline-block;
            /* Fit content */
        }

        .grid {
            display: grid;
            gap: 1px;
            background-color: var(--text-color);
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: var(--cell-closed);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'IBM Plex Mono', monospace;
            font-weight: 700;
            font-size: 18px;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .cell:hover:not(.revealed) {
            background-color: var(--cell-hover);
        }

        .cell.revealed {
            background-color: var(--cell-open);
            cursor: default;
        }

        .cell.mine {
            background-color: var(--accent-red);
            color: white;
        }

        .cell.flagged {
            color: var(--accent-red);
        }

        /* Number Colors */
        .num-1 {
            color: #0055ff;
        }

        .num-2 {
            color: #10B981;
        }

        .num-3 {
            color: #ef4444;
        }

        .num-4 {
            color: #8b5cf6;
        }

        .num-5 {
            color: #f59e0b;
        }

        .num-6 {
            color: #06b6d4;
        }

        .num-7 {
            color: #111111;
        }

        .num-8 {
            color: #666666;
        }

        /* Footer / Instructions */
        .instructions {
            margin-top: 40px;
            font-size: 12px;
            color: var(--secondary-text);
            text-align: center;
            max-width: 400px;
        }

        .back-link {
            position: absolute;
            top: 40px;
            left: 40px;
            text-decoration: none;
            color: var(--text-color);
            font-weight: 600;
            font-size: 14px;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        @media (max-width: 600px) {
            body {
                padding: 20px;
            }

            h1 {
                font-size: 32px;
            }

            .back-link {
                position: static;
                align-self: flex-start;
                margin-bottom: 20px;
            }

            :root {
                --cell-size: 28px;
            }
        }
    </style>
</head>

<body>
    <a href="../index.html" class="back-link">‚Üê Back to Index</a>

    <div class="container">
        <header>
            <h1>Minesweeper</h1>
            <div class="subtitle">Logic Puzzle</div>
        </header>

        <div class="difficulty-selector">
            <button class="diff-btn active" data-diff="easy">Easy (9x9)</button>
            <button class="diff-btn" data-diff="medium">Medium (16x16)</button>
            <button class="diff-btn" data-diff="hard">Hard (30x16)</button>
        </div>

        <div class="controls">
            <div class="stat-box">
                <span>üí£</span>
                <span id="mine-count">010</span>
            </div>

            <button id="reset-btn" class="face-btn">üòä</button>

            <div class="stat-box">
                <span>‚è±Ô∏è</span>
                <span id="timer">000</span>
            </div>
        </div>

        <div class="game-wrapper">
            <div id="grid" class="grid"></div>
        </div>

        <div class="instructions">
            <p>Left Click to Reveal ‚Ä¢ Right Click to Flag</p>
            <p style="margin-top:8px;">Long press on touch devices to flag.</p>
        </div>
    </div>

    <script>
        // --- GAME CONFIGURATION ---
        const CONFIG = {
            easy: { rows: 9, cols: 9, mines: 10 },
            medium: { rows: 16, cols: 16, mines: 40 },
            hard: { rows: 16, cols: 30, mines: 99 }
        };

        let state = {
            difficulty: 'easy',
            grid: [],
            minesRemaining: 10,
            time: 0,
            timerId: null,
            gameOver: false,
            firstClick: true
        };

        // --- DOM ELEMENTS ---
        const gridEl = document.getElementById('grid');
        const mineCountEl = document.getElementById('mine-count');
        const timerEl = document.getElementById('timer');
        const resetBtn = document.getElementById('reset-btn');
        const diffBtns = document.querySelectorAll('.diff-btn');

        // --- INITIALIZATION ---
        function init() {
            // Event Listeners
            resetBtn.addEventListener('click', () => startGame(state.difficulty));

            diffBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    diffBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    startGame(btn.dataset.diff);
                });
            });

            startGame('easy');
        }

        function startGame(difficulty) {
            // Reset State
            if (state.timerId) clearInterval(state.timerId);
            state = {
                difficulty: difficulty,
                grid: [],
                minesRemaining: CONFIG[difficulty].mines,
                time: 0,
                timerId: null,
                gameOver: false,
                firstClick: true
            };

            // Reset UI
            resetBtn.textContent = 'üòä';
            mineCountEl.textContent = state.minesRemaining.toString().padStart(3, '0');
            timerEl.textContent = '000';

            renderGrid();
        }

        function renderGrid() {
            const cfg = CONFIG[state.difficulty];
            gridEl.innerHTML = '';

            // Set grid columns
            gridEl.style.gridTemplateColumns = `repeat(${cfg.cols}, var(--cell-size))`;

            // Create Cells
            for (let r = 0; r < cfg.rows; r++) {
                state.grid[r] = [];
                for (let c = 0; c < cfg.cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.r = r;
                    cell.dataset.c = c;

                    // Interaction
                    cell.addEventListener('mousedown', (e) => handleInput(e, r, c));
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        toggleFlag(r, c);
                    });

                    // Logic State
                    state.grid[r][c] = {
                        isMine: false,
                        revealed: false,
                        flagged: false,
                        neighborMines: 0,
                        element: cell
                    };

                    gridEl.appendChild(cell);
                }
            }
        }

        // --- GAME LOGIC ---

        function handleInput(e, r, c) {
            if (state.gameOver) return;

            // Handle Right Click via mousedown checks if contextmenu fails or specific mouse buttons
            if (e.button === 2) {
                // Handled by contextmenu usually, but ignore here to prevent double fire
                return;
            }

            if (state.firstClick) {
                generateMines(r, c);
                state.firstClick = false;
                startTimer();
            }

            reveal(r, c);
        }

        function generateMines(safeR, safeC) {
            const cfg = CONFIG[state.difficulty];
            let placed = 0;
            while (placed < cfg.mines) {
                const rr = Math.floor(Math.random() * cfg.rows);
                const cc = Math.floor(Math.random() * cfg.cols);

                // Avoid existing mines and the safe starting zone
                if (!state.grid[rr][cc].isMine && (rr !== safeR || cc !== safeC)) {
                    state.grid[rr][cc].isMine = true;
                    placed++;
                }
            }
            calculateNeighbors();
        }

        function calculateNeighbors() {
            const cfg = CONFIG[state.difficulty];
            for (let r = 0; r < cfg.rows; r++) {
                for (let c = 0; c < cfg.cols; c++) {
                    if (state.grid[r][c].isMine) continue;
                    let count = 0;
                    // Check 8 neighbors
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = r + dr, nc = c + dc;
                            if (nr >= 0 && nr < cfg.rows && nc >= 0 && nc < cfg.cols) {
                                if (state.grid[nr][nc].isMine) count++;
                            }
                        }
                    }
                    state.grid[r][c].neighborMines = count;
                }
            }
        }

        function reveal(r, c) {
            const cell = state.grid[r][c];
            if (cell.revealed || cell.flagged || state.gameOver) return;

            cell.revealed = true;
            cell.element.classList.add('revealed');

            if (cell.isMine) {
                explode();
                return;
            }

            if (cell.neighborMines > 0) {
                cell.element.textContent = cell.neighborMines;
                cell.element.className = `cell revealed num-${cell.neighborMines}`;
            } else {
                // Flood fill
                const cfg = CONFIG[state.difficulty];
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const nr = r + dr, nc = c + dc;
                        if (nr >= 0 && nr < cfg.rows && nc >= 0 && nc < cfg.cols) {
                            reveal(nr, nc);
                        }
                    }
                }
            }

            checkWin();
        }

        function toggleFlag(r, c) {
            if (state.gameOver) return;
            const cell = state.grid[r][c];
            if (cell.revealed) return;

            cell.flagged = !cell.flagged;
            cell.element.classList.toggle('flagged');
            cell.element.textContent = cell.flagged ? 'üö©' : '';

            state.minesRemaining += cell.flagged ? -1 : 1;
            mineCountEl.textContent = state.minesRemaining.toString().padStart(3, '0');
        }

        function explode() {
            state.gameOver = true;
            clearInterval(state.timerId);
            resetBtn.textContent = 'üòµ';

            // Reveal all mines
            state.grid.flat().forEach(cell => {
                if (cell.isMine) {
                    cell.element.classList.add('revealed', 'mine');
                    cell.element.textContent = 'üí£';
                }
            });
        }

        function checkWin() {
            const cfg = CONFIG[state.difficulty];
            const totalCells = cfg.rows * cfg.cols;
            const revealedCount = state.grid.flat().filter(c => c.revealed).length;

            if (revealedCount === totalCells - cfg.mines) {
                state.gameOver = true;
                clearInterval(state.timerId);
                resetBtn.textContent = 'üòé';
                mineCountEl.textContent = "000";

                // Flag all mines
                state.grid.flat().forEach(cell => {
                    if (cell.isMine && !cell.flagged) {
                        cell.flagged = true;
                        cell.element.textContent = 'üö©';
                        cell.element.classList.add('flagged');
                    }
                });
            }
        }

        function startTimer() {
            state.timerId = setInterval(() => {
                state.time++;
                timerEl.textContent = state.time.toString().padStart(3, '0');
            }, 1000);
        }

        // Initialize
        init();

    </script>
</body>

</html>